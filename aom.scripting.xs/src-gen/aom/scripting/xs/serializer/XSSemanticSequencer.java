/*
 * generated by Xtext
 */
package aom.scripting.xs.serializer;

import aom.scripting.xs.services.XSGrammarAccess;
import aom.scripting.xs.xs.AndExpression;
import aom.scripting.xs.xs.Assign;
import aom.scripting.xs.xs.Block;
import aom.scripting.xs.xs.BoolType;
import aom.scripting.xs.xs.BreakStatement;
import aom.scripting.xs.xs.Call;
import aom.scripting.xs.xs.ComparisonExpression;
import aom.scripting.xs.xs.ContinueStatement;
import aom.scripting.xs.xs.EqualsExpression;
import aom.scripting.xs.xs.Factor;
import aom.scripting.xs.xs.FloatType;
import aom.scripting.xs.xs.ForStatement;
import aom.scripting.xs.xs.ForVarDeclaration;
import aom.scripting.xs.xs.FunctionDeclaration;
import aom.scripting.xs.xs.GlobalVarDeclaration;
import aom.scripting.xs.xs.IfElseStatement;
import aom.scripting.xs.xs.IncludeDeclaration;
import aom.scripting.xs.xs.IntType;
import aom.scripting.xs.xs.LiteralBool;
import aom.scripting.xs.xs.LiteralFloat;
import aom.scripting.xs.xs.LiteralInt;
import aom.scripting.xs.xs.LiteralString;
import aom.scripting.xs.xs.LocalVarDeclaration;
import aom.scripting.xs.xs.OrExpression;
import aom.scripting.xs.xs.ParameterDeclaration;
import aom.scripting.xs.xs.PostfixStatement;
import aom.scripting.xs.xs.Program;
import aom.scripting.xs.xs.ReturnStatement;
import aom.scripting.xs.xs.RuleDeclaration;
import aom.scripting.xs.xs.StringType;
import aom.scripting.xs.xs.SwitchCase;
import aom.scripting.xs.xs.SwitchDefault;
import aom.scripting.xs.xs.SwitchStatement;
import aom.scripting.xs.xs.Term;
import aom.scripting.xs.xs.Var;
import aom.scripting.xs.xs.VectorLiteral;
import aom.scripting.xs.xs.VectorType;
import aom.scripting.xs.xs.VoidType;
import aom.scripting.xs.xs.WhileStatement;
import aom.scripting.xs.xs.XsPackage;
import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;

@SuppressWarnings("all")
public class XSSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private XSGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == XsPackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case XsPackage.AND_EXPRESSION:
				sequence_AndExpression(context, (AndExpression) semanticObject); 
				return; 
			case XsPackage.ASSIGN:
				sequence_Assign(context, (Assign) semanticObject); 
				return; 
			case XsPackage.BLOCK:
				sequence_Block(context, (Block) semanticObject); 
				return; 
			case XsPackage.BOOL_TYPE:
				sequence_BoolType(context, (BoolType) semanticObject); 
				return; 
			case XsPackage.BREAK_STATEMENT:
				sequence_BreakStatement(context, (BreakStatement) semanticObject); 
				return; 
			case XsPackage.CALL:
				sequence_Call(context, (Call) semanticObject); 
				return; 
			case XsPackage.COMPARISON_EXPRESSION:
				sequence_ComparisonExpression(context, (ComparisonExpression) semanticObject); 
				return; 
			case XsPackage.CONTINUE_STATEMENT:
				sequence_ContinueStatement(context, (ContinueStatement) semanticObject); 
				return; 
			case XsPackage.EQUALS_EXPRESSION:
				sequence_EqualsExpression(context, (EqualsExpression) semanticObject); 
				return; 
			case XsPackage.FACTOR:
				sequence_MultiplicativeExpression(context, (Factor) semanticObject); 
				return; 
			case XsPackage.FLOAT_TYPE:
				sequence_FloatType(context, (FloatType) semanticObject); 
				return; 
			case XsPackage.FOR_STATEMENT:
				sequence_ForStatement(context, (ForStatement) semanticObject); 
				return; 
			case XsPackage.FOR_VAR_DECLARATION:
				sequence_ForVarDeclaration(context, (ForVarDeclaration) semanticObject); 
				return; 
			case XsPackage.FUNCTION_DECLARATION:
				sequence_FunctionDeclaration(context, (FunctionDeclaration) semanticObject); 
				return; 
			case XsPackage.GLOBAL_VAR_DECLARATION:
				sequence_GlobalVarDeclaration(context, (GlobalVarDeclaration) semanticObject); 
				return; 
			case XsPackage.IF_ELSE_STATEMENT:
				sequence_IfElseStatement(context, (IfElseStatement) semanticObject); 
				return; 
			case XsPackage.INCLUDE_DECLARATION:
				if (rule == grammarAccess.getIncludeDeclarationRule()) {
					sequence_IncludeDeclaration(context, (IncludeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeclarationRule()) {
					sequence_IncludeDeclaration_PseudoIncludeDeclaration(context, (IncludeDeclaration) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getPseudoIncludeDeclarationRule()) {
					sequence_PseudoIncludeDeclaration(context, (IncludeDeclaration) semanticObject); 
					return; 
				}
				else break;
			case XsPackage.INT_TYPE:
				sequence_IntType(context, (IntType) semanticObject); 
				return; 
			case XsPackage.LITERAL_BOOL:
				sequence_LiteralNum(context, (LiteralBool) semanticObject); 
				return; 
			case XsPackage.LITERAL_FLOAT:
				sequence_LiteralNum(context, (LiteralFloat) semanticObject); 
				return; 
			case XsPackage.LITERAL_INT:
				sequence_LiteralNum(context, (LiteralInt) semanticObject); 
				return; 
			case XsPackage.LITERAL_STRING:
				sequence_Literal(context, (LiteralString) semanticObject); 
				return; 
			case XsPackage.LOCAL_VAR_DECLARATION:
				sequence_LocalVarDeclaration(context, (LocalVarDeclaration) semanticObject); 
				return; 
			case XsPackage.OR_EXPRESSION:
				sequence_SimpleExpression(context, (OrExpression) semanticObject); 
				return; 
			case XsPackage.PARAMETER_DECLARATION:
				sequence_ParameterDeclaration(context, (ParameterDeclaration) semanticObject); 
				return; 
			case XsPackage.POSTFIX_STATEMENT:
				sequence_PostfixStatement(context, (PostfixStatement) semanticObject); 
				return; 
			case XsPackage.PROGRAM:
				sequence_Program(context, (Program) semanticObject); 
				return; 
			case XsPackage.RETURN_STATEMENT:
				sequence_ReturnStatement(context, (ReturnStatement) semanticObject); 
				return; 
			case XsPackage.RULE_DECLARATION:
				sequence_RuleDeclaration(context, (RuleDeclaration) semanticObject); 
				return; 
			case XsPackage.STRING_TYPE:
				sequence_StringType(context, (StringType) semanticObject); 
				return; 
			case XsPackage.SWITCH_CASE:
				sequence_SwitchCase(context, (SwitchCase) semanticObject); 
				return; 
			case XsPackage.SWITCH_DEFAULT:
				sequence_SwitchDefault(context, (SwitchDefault) semanticObject); 
				return; 
			case XsPackage.SWITCH_STATEMENT:
				sequence_SwitchStatement(context, (SwitchStatement) semanticObject); 
				return; 
			case XsPackage.TERM:
				sequence_AdditiveExpression(context, (Term) semanticObject); 
				return; 
			case XsPackage.VAR:
				sequence_Var(context, (Var) semanticObject); 
				return; 
			case XsPackage.VECTOR_LITERAL:
				sequence_Vector(context, (VectorLiteral) semanticObject); 
				return; 
			case XsPackage.VECTOR_TYPE:
				sequence_VectorType(context, (VectorType) semanticObject); 
				return; 
			case XsPackage.VOID_TYPE:
				sequence_VoidType(context, (VoidType) semanticObject); 
				return; 
			case XsPackage.WHILE_STATEMENT:
				sequence_WhileStatement(context, (WhileStatement) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Expression returns Term
	 *     SimpleExpression returns Term
	 *     SimpleExpression.OrExpression_1_0 returns Term
	 *     AndExpression returns Term
	 *     AndExpression.AndExpression_1_0 returns Term
	 *     EqualsExpression returns Term
	 *     EqualsExpression.EqualsExpression_1_0 returns Term
	 *     ComparisonExpression returns Term
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Term
	 *     AdditiveExpression returns Term
	 *     AdditiveExpression.Term_1_0 returns Term
	 *     MultiplicativeExpression returns Term
	 *     MultiplicativeExpression.Factor_1_0 returns Term
	 *     Atom returns Term
	 *
	 * Constraint:
	 *     (left=AdditiveExpression_Term_1_0 op=AddOp right=MultiplicativeExpression)
	 */
	protected void sequence_AdditiveExpression(ISerializationContext context, Term semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.TERM__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.TERM__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getTermLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getOpAddOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAdditiveExpressionAccess().getRightMultiplicativeExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns AndExpression
	 *     SimpleExpression returns AndExpression
	 *     SimpleExpression.OrExpression_1_0 returns AndExpression
	 *     AndExpression returns AndExpression
	 *     AndExpression.AndExpression_1_0 returns AndExpression
	 *     EqualsExpression returns AndExpression
	 *     EqualsExpression.EqualsExpression_1_0 returns AndExpression
	 *     ComparisonExpression returns AndExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns AndExpression
	 *     AdditiveExpression returns AndExpression
	 *     AdditiveExpression.Term_1_0 returns AndExpression
	 *     MultiplicativeExpression returns AndExpression
	 *     MultiplicativeExpression.Factor_1_0 returns AndExpression
	 *     Atom returns AndExpression
	 *
	 * Constraint:
	 *     (left=AndExpression_AndExpression_1_0 op='&&' right=EqualsExpression)
	 */
	protected void sequence_AndExpression(ISerializationContext context, AndExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.AND_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.AND_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAndExpressionAccess().getAndExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getAndExpressionAccess().getOpAmpersandAmpersandKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getAndExpressionAccess().getRightEqualsExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns Assign
	 *     StatementOrBlock returns Assign
	 *     Statement returns Assign
	 *     ExpressionStatement returns Assign
	 *     Expression returns Assign
	 *     Assign returns Assign
	 *     SimpleExpression returns Assign
	 *     SimpleExpression.OrExpression_1_0 returns Assign
	 *     AndExpression returns Assign
	 *     AndExpression.AndExpression_1_0 returns Assign
	 *     EqualsExpression returns Assign
	 *     EqualsExpression.EqualsExpression_1_0 returns Assign
	 *     ComparisonExpression returns Assign
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Assign
	 *     AdditiveExpression returns Assign
	 *     AdditiveExpression.Term_1_0 returns Assign
	 *     MultiplicativeExpression returns Assign
	 *     MultiplicativeExpression.Factor_1_0 returns Assign
	 *     Atom returns Assign
	 *
	 * Constraint:
	 *     (var=Var expression=Expression)
	 */
	protected void sequence_Assign(ISerializationContext context, Assign semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.ASSIGN__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.ASSIGN__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.ASSIGN__EXPRESSION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.ASSIGN__EXPRESSION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAssignAccess().getVarVarParserRuleCall_1_0_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getAssignAccess().getExpressionExpressionParserRuleCall_1_2_0(), semanticObject.getExpression());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Block returns Block
	 *     StatementOrBlock returns Block
	 *
	 * Constraint:
	 *     contents+=VarDeclarationOrStatement*
	 */
	protected void sequence_Block(ISerializationContext context, Block semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns BoolType
	 *     VarTypeSpecifier returns BoolType
	 *     BoolType returns BoolType
	 *
	 * Constraint:
	 *     {BoolType}
	 */
	protected void sequence_BoolType(ISerializationContext context, BoolType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns BreakStatement
	 *     StatementOrBlock returns BreakStatement
	 *     Statement returns BreakStatement
	 *     BreakStatement returns BreakStatement
	 *
	 * Constraint:
	 *     {BreakStatement}
	 */
	protected void sequence_BreakStatement(ISerializationContext context, BreakStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns Call
	 *     StatementOrBlock returns Call
	 *     Statement returns Call
	 *     ExpressionStatement returns Call
	 *     Expression returns Call
	 *     SimpleExpression returns Call
	 *     SimpleExpression.OrExpression_1_0 returns Call
	 *     AndExpression returns Call
	 *     AndExpression.AndExpression_1_0 returns Call
	 *     EqualsExpression returns Call
	 *     EqualsExpression.EqualsExpression_1_0 returns Call
	 *     ComparisonExpression returns Call
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Call
	 *     AdditiveExpression returns Call
	 *     AdditiveExpression.Term_1_0 returns Call
	 *     MultiplicativeExpression returns Call
	 *     MultiplicativeExpression.Factor_1_0 returns Call
	 *     Atom returns Call
	 *     Call returns Call
	 *
	 * Constraint:
	 *     (function=[FunctionDeclaration|ID] (arguments+=Expression arguments+=Expression*)?)
	 */
	protected void sequence_Call(ISerializationContext context, Call semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns ComparisonExpression
	 *     SimpleExpression returns ComparisonExpression
	 *     SimpleExpression.OrExpression_1_0 returns ComparisonExpression
	 *     AndExpression returns ComparisonExpression
	 *     AndExpression.AndExpression_1_0 returns ComparisonExpression
	 *     EqualsExpression returns ComparisonExpression
	 *     EqualsExpression.EqualsExpression_1_0 returns ComparisonExpression
	 *     ComparisonExpression returns ComparisonExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns ComparisonExpression
	 *     AdditiveExpression returns ComparisonExpression
	 *     AdditiveExpression.Term_1_0 returns ComparisonExpression
	 *     MultiplicativeExpression returns ComparisonExpression
	 *     MultiplicativeExpression.Factor_1_0 returns ComparisonExpression
	 *     Atom returns ComparisonExpression
	 *
	 * Constraint:
	 *     (left=ComparisonExpression_ComparisonExpression_1_0 op=RelOp right=AdditiveExpression)
	 */
	protected void sequence_ComparisonExpression(ISerializationContext context, ComparisonExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.COMPARISON_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getComparisonExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getOpRelOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getComparisonExpressionAccess().getRightAdditiveExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ContinueStatement
	 *     StatementOrBlock returns ContinueStatement
	 *     Statement returns ContinueStatement
	 *     ContinueStatement returns ContinueStatement
	 *
	 * Constraint:
	 *     {ContinueStatement}
	 */
	protected void sequence_ContinueStatement(ISerializationContext context, ContinueStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns EqualsExpression
	 *     SimpleExpression returns EqualsExpression
	 *     SimpleExpression.OrExpression_1_0 returns EqualsExpression
	 *     AndExpression returns EqualsExpression
	 *     AndExpression.AndExpression_1_0 returns EqualsExpression
	 *     EqualsExpression returns EqualsExpression
	 *     EqualsExpression.EqualsExpression_1_0 returns EqualsExpression
	 *     ComparisonExpression returns EqualsExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns EqualsExpression
	 *     AdditiveExpression returns EqualsExpression
	 *     AdditiveExpression.Term_1_0 returns EqualsExpression
	 *     MultiplicativeExpression returns EqualsExpression
	 *     MultiplicativeExpression.Factor_1_0 returns EqualsExpression
	 *     Atom returns EqualsExpression
	 *
	 * Constraint:
	 *     (left=EqualsExpression_EqualsExpression_1_0 op=EqOp right=ComparisonExpression)
	 */
	protected void sequence_EqualsExpression(ISerializationContext context, EqualsExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.EQUALS_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getEqualsExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getOpEqOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getEqualsExpressionAccess().getRightComparisonExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns FloatType
	 *     VarTypeSpecifier returns FloatType
	 *     FloatType returns FloatType
	 *
	 * Constraint:
	 *     {FloatType}
	 */
	protected void sequence_FloatType(ISerializationContext context, FloatType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ForStatement
	 *     StatementOrBlock returns ForStatement
	 *     Statement returns ForStatement
	 *     ForStatement returns ForStatement
	 *
	 * Constraint:
	 *     (var=ForVarDeclaration op=RelOp end=Expression statement=StatementOrBlock)
	 */
	protected void sequence_ForStatement(ISerializationContext context, ForStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__END) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__END));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FOR_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FOR_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForStatementAccess().getVarForVarDeclarationParserRuleCall_3_0(), semanticObject.getVar());
		feeder.accept(grammarAccess.getForStatementAccess().getOpRelOpParserRuleCall_5_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getForStatementAccess().getEndExpressionParserRuleCall_6_0(), semanticObject.getEnd());
		feeder.accept(grammarAccess.getForStatementAccess().getStatementStatementOrBlockParserRuleCall_8_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns ForVarDeclaration
	 *     ForVarDeclaration returns ForVarDeclaration
	 *
	 * Constraint:
	 *     (name=ID value=Expression)
	 */
	protected void sequence_ForVarDeclaration(ISerializationContext context, ForVarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getForVarDeclarationAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getForVarDeclarationAccess().getValueExpressionParserRuleCall_3_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns FunctionDeclaration
	 *     FunctionDeclaration returns FunctionDeclaration
	 *
	 * Constraint:
	 *     (mutable?='mutable'? type=FunctionTypeSpecifier name=ID (parameters+=ParameterDeclaration parameters+=ParameterDeclaration*)? body=Block)
	 */
	protected void sequence_FunctionDeclaration(ISerializationContext context, FunctionDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns GlobalVarDeclaration
	 *     VarDeclaration returns GlobalVarDeclaration
	 *     GlobalVarDeclaration returns GlobalVarDeclaration
	 *
	 * Constraint:
	 *     ((const?='const' | extern?='extern')* type=VarTypeSpecifier name=ID value=LiteralOrVar)
	 */
	protected void sequence_GlobalVarDeclaration(ISerializationContext context, GlobalVarDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns IfElseStatement
	 *     StatementOrBlock returns IfElseStatement
	 *     Statement returns IfElseStatement
	 *     IfElseStatement returns IfElseStatement
	 *
	 * Constraint:
	 *     (condition=Expression thenStatement=StatementOrBlock elseStatement=StatementOrBlock?)
	 */
	protected void sequence_IfElseStatement(ISerializationContext context, IfElseStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     IncludeDeclaration returns IncludeDeclaration
	 *
	 * Constraint:
	 *     filePath=STRING
	 */
	protected void sequence_IncludeDeclaration(ISerializationContext context, IncludeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.INCLUDE_DECLARATION__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.INCLUDE_DECLARATION__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIncludeDeclarationAccess().getFilePathSTRINGTerminalRuleCall_2_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns IncludeDeclaration
	 *
	 * Constraint:
	 *     (filePath=STRING | filePath=STRING)
	 */
	protected void sequence_IncludeDeclaration_PseudoIncludeDeclaration(ISerializationContext context, IncludeDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns IntType
	 *     VarTypeSpecifier returns IntType
	 *     IntType returns IntType
	 *
	 * Constraint:
	 *     {IntType}
	 */
	protected void sequence_IntType(ISerializationContext context, IntType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralBool
	 *     SimpleExpression returns LiteralBool
	 *     SimpleExpression.OrExpression_1_0 returns LiteralBool
	 *     AndExpression returns LiteralBool
	 *     AndExpression.AndExpression_1_0 returns LiteralBool
	 *     EqualsExpression returns LiteralBool
	 *     EqualsExpression.EqualsExpression_1_0 returns LiteralBool
	 *     ComparisonExpression returns LiteralBool
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LiteralBool
	 *     AdditiveExpression returns LiteralBool
	 *     AdditiveExpression.Term_1_0 returns LiteralBool
	 *     MultiplicativeExpression returns LiteralBool
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralBool
	 *     Atom returns LiteralBool
	 *     LiteralOrVar returns LiteralBool
	 *     LiteralNumOrVar returns LiteralBool
	 *     Literal returns LiteralBool
	 *     LiteralNum returns LiteralBool
	 *
	 * Constraint:
	 *     value=Bool
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralBool semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_BOOL__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_BOOL__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueBoolParserRuleCall_2_1_0(), semanticObject.isValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralFloat
	 *     SimpleExpression returns LiteralFloat
	 *     SimpleExpression.OrExpression_1_0 returns LiteralFloat
	 *     AndExpression returns LiteralFloat
	 *     AndExpression.AndExpression_1_0 returns LiteralFloat
	 *     EqualsExpression returns LiteralFloat
	 *     EqualsExpression.EqualsExpression_1_0 returns LiteralFloat
	 *     ComparisonExpression returns LiteralFloat
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LiteralFloat
	 *     AdditiveExpression returns LiteralFloat
	 *     AdditiveExpression.Term_1_0 returns LiteralFloat
	 *     MultiplicativeExpression returns LiteralFloat
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralFloat
	 *     Atom returns LiteralFloat
	 *     LiteralOrVar returns LiteralFloat
	 *     LiteralNumOrVar returns LiteralFloat
	 *     Literal returns LiteralFloat
	 *     LiteralNum returns LiteralFloat
	 *
	 * Constraint:
	 *     value=SignedFloat
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralFloat semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_FLOAT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_FLOAT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueSignedFloatParserRuleCall_1_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralInt
	 *     SimpleExpression returns LiteralInt
	 *     SimpleExpression.OrExpression_1_0 returns LiteralInt
	 *     AndExpression returns LiteralInt
	 *     AndExpression.AndExpression_1_0 returns LiteralInt
	 *     EqualsExpression returns LiteralInt
	 *     EqualsExpression.EqualsExpression_1_0 returns LiteralInt
	 *     ComparisonExpression returns LiteralInt
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LiteralInt
	 *     AdditiveExpression returns LiteralInt
	 *     AdditiveExpression.Term_1_0 returns LiteralInt
	 *     MultiplicativeExpression returns LiteralInt
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralInt
	 *     Atom returns LiteralInt
	 *     LiteralOrVar returns LiteralInt
	 *     LiteralNumOrVar returns LiteralInt
	 *     Literal returns LiteralInt
	 *     LiteralNum returns LiteralInt
	 *
	 * Constraint:
	 *     value=SignedInt
	 */
	protected void sequence_LiteralNum(ISerializationContext context, LiteralInt semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_INT__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_INT__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralNumAccess().getValueSignedIntParserRuleCall_0_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns LiteralString
	 *     SimpleExpression returns LiteralString
	 *     SimpleExpression.OrExpression_1_0 returns LiteralString
	 *     AndExpression returns LiteralString
	 *     AndExpression.AndExpression_1_0 returns LiteralString
	 *     EqualsExpression returns LiteralString
	 *     EqualsExpression.EqualsExpression_1_0 returns LiteralString
	 *     ComparisonExpression returns LiteralString
	 *     ComparisonExpression.ComparisonExpression_1_0 returns LiteralString
	 *     AdditiveExpression returns LiteralString
	 *     AdditiveExpression.Term_1_0 returns LiteralString
	 *     MultiplicativeExpression returns LiteralString
	 *     MultiplicativeExpression.Factor_1_0 returns LiteralString
	 *     Atom returns LiteralString
	 *     LiteralOrVar returns LiteralString
	 *     Literal returns LiteralString
	 *
	 * Constraint:
	 *     value=STRING
	 */
	protected void sequence_Literal(ISerializationContext context, LiteralString semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LITERAL_STRING__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LITERAL_STRING__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLiteralAccess().getValueSTRINGTerminalRuleCall_2_1_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns LocalVarDeclaration
	 *     LocalVarDeclaration returns LocalVarDeclaration
	 *     VarDeclarationOrStatement returns LocalVarDeclaration
	 *
	 * Constraint:
	 *     (type=VarTypeSpecifier name=ID value=Expression)
	 */
	protected void sequence_LocalVarDeclaration(ISerializationContext context, LocalVarDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.LOCAL_VAR_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.LOCAL_VAR_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getLocalVarDeclarationAccess().getTypeVarTypeSpecifierParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getLocalVarDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getLocalVarDeclarationAccess().getValueExpressionParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Factor
	 *     SimpleExpression returns Factor
	 *     SimpleExpression.OrExpression_1_0 returns Factor
	 *     AndExpression returns Factor
	 *     AndExpression.AndExpression_1_0 returns Factor
	 *     EqualsExpression returns Factor
	 *     EqualsExpression.EqualsExpression_1_0 returns Factor
	 *     ComparisonExpression returns Factor
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Factor
	 *     AdditiveExpression returns Factor
	 *     AdditiveExpression.Term_1_0 returns Factor
	 *     MultiplicativeExpression returns Factor
	 *     MultiplicativeExpression.Factor_1_0 returns Factor
	 *     Atom returns Factor
	 *
	 * Constraint:
	 *     (left=MultiplicativeExpression_Factor_1_0 op=MulOp right=Atom)
	 */
	protected void sequence_MultiplicativeExpression(ISerializationContext context, Factor semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.FACTOR__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.FACTOR__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getFactorLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getOpMulOpParserRuleCall_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getMultiplicativeExpressionAccess().getRightAtomParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclaration returns ParameterDeclaration
	 *     ParameterDeclaration returns ParameterDeclaration
	 *
	 * Constraint:
	 *     (type=VarTypeSpecifier name=ID value=LiteralOrVar)
	 */
	protected void sequence_ParameterDeclaration(ISerializationContext context, ParameterDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.PARAMETER_DECLARATION__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.PARAMETER_DECLARATION__TYPE));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__NAME));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR_DECLARATION__VALUE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getTypeVarTypeSpecifierParserRuleCall_1_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getNameIDTerminalRuleCall_2_0(), semanticObject.getName());
		feeder.accept(grammarAccess.getParameterDeclarationAccess().getValueLiteralOrVarParserRuleCall_4_0(), semanticObject.getValue());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns PostfixStatement
	 *     StatementOrBlock returns PostfixStatement
	 *     Statement returns PostfixStatement
	 *     PostfixStatement returns PostfixStatement
	 *
	 * Constraint:
	 *     (var=[VarDeclaration|ID] op=PostFixOp)
	 */
	protected void sequence_PostfixStatement(ISerializationContext context, PostfixStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__VAR) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__VAR));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.POSTFIX_STATEMENT__OP));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPostfixStatementAccess().getVarVarDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.getVar());
		feeder.accept(grammarAccess.getPostfixStatementAccess().getOpPostFixOpParserRuleCall_2_0(), semanticObject.getOp());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Program returns Program
	 *
	 * Constraint:
	 *     declarations+=Declaration*
	 */
	protected void sequence_Program(ISerializationContext context, Program semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     PseudoIncludeDeclaration returns IncludeDeclaration
	 *
	 * Constraint:
	 *     filePath=STRING
	 */
	protected void sequence_PseudoIncludeDeclaration(ISerializationContext context, IncludeDeclaration semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.INCLUDE_DECLARATION__FILE_PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.INCLUDE_DECLARATION__FILE_PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPseudoIncludeDeclarationAccess().getFilePathSTRINGTerminalRuleCall_3_0(), semanticObject.getFilePath());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns ReturnStatement
	 *     StatementOrBlock returns ReturnStatement
	 *     Statement returns ReturnStatement
	 *     ReturnStatement returns ReturnStatement
	 *
	 * Constraint:
	 *     expression=Expression?
	 */
	protected void sequence_ReturnStatement(ISerializationContext context, ReturnStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Declaration returns RuleDeclaration
	 *     RuleDeclaration returns RuleDeclaration
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             active?='active' | 
	 *             runImmediately?='runImmediately' | 
	 *             highFrequency?='highFrequency' | 
	 *             group=ID | 
	 *             minInterval=INT | 
	 *             maxInterval=INT | 
	 *             priority=INT
	 *         )* 
	 *         body=Block
	 *     )
	 */
	protected void sequence_RuleDeclaration(ISerializationContext context, RuleDeclaration semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns OrExpression
	 *     SimpleExpression returns OrExpression
	 *     SimpleExpression.OrExpression_1_0 returns OrExpression
	 *     AndExpression returns OrExpression
	 *     AndExpression.AndExpression_1_0 returns OrExpression
	 *     EqualsExpression returns OrExpression
	 *     EqualsExpression.EqualsExpression_1_0 returns OrExpression
	 *     ComparisonExpression returns OrExpression
	 *     ComparisonExpression.ComparisonExpression_1_0 returns OrExpression
	 *     AdditiveExpression returns OrExpression
	 *     AdditiveExpression.Term_1_0 returns OrExpression
	 *     MultiplicativeExpression returns OrExpression
	 *     MultiplicativeExpression.Factor_1_0 returns OrExpression
	 *     Atom returns OrExpression
	 *
	 * Constraint:
	 *     (left=SimpleExpression_OrExpression_1_0 op='||' right=AndExpression)
	 */
	protected void sequence_SimpleExpression(ISerializationContext context, OrExpression semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR_EXPRESSION__LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR_EXPRESSION__LEFT));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR_EXPRESSION__OP) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR_EXPRESSION__OP));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.OR_EXPRESSION__RIGHT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.OR_EXPRESSION__RIGHT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getOrExpressionLeftAction_1_0(), semanticObject.getLeft());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getOpVerticalLineVerticalLineKeyword_1_1_0(), semanticObject.getOp());
		feeder.accept(grammarAccess.getSimpleExpressionAccess().getRightAndExpressionParserRuleCall_1_2_0(), semanticObject.getRight());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns StringType
	 *     VarTypeSpecifier returns StringType
	 *     StringType returns StringType
	 *
	 * Constraint:
	 *     {StringType}
	 */
	protected void sequence_StringType(ISerializationContext context, StringType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchCase returns SwitchCase
	 *
	 * Constraint:
	 *     ((value=LiteralNumOrVar | value=LiteralNumOrVar) statement=StatementOrBlock)
	 */
	protected void sequence_SwitchCase(ISerializationContext context, SwitchCase semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     SwitchDefault returns SwitchDefault
	 *
	 * Constraint:
	 *     statement=StatementOrBlock
	 */
	protected void sequence_SwitchDefault(ISerializationContext context, SwitchDefault semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.SWITCH_DEFAULT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.SWITCH_DEFAULT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getSwitchDefaultAccess().getStatementStatementOrBlockParserRuleCall_3_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns SwitchStatement
	 *     StatementOrBlock returns SwitchStatement
	 *     Statement returns SwitchStatement
	 *     SwitchStatement returns SwitchStatement
	 *
	 * Constraint:
	 *     (expression=Expression cases+=SwitchCase* default=SwitchDefault?)
	 */
	protected void sequence_SwitchStatement(ISerializationContext context, SwitchStatement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns Var
	 *     SimpleExpression returns Var
	 *     SimpleExpression.OrExpression_1_0 returns Var
	 *     AndExpression returns Var
	 *     AndExpression.AndExpression_1_0 returns Var
	 *     EqualsExpression returns Var
	 *     EqualsExpression.EqualsExpression_1_0 returns Var
	 *     ComparisonExpression returns Var
	 *     ComparisonExpression.ComparisonExpression_1_0 returns Var
	 *     AdditiveExpression returns Var
	 *     AdditiveExpression.Term_1_0 returns Var
	 *     MultiplicativeExpression returns Var
	 *     MultiplicativeExpression.Factor_1_0 returns Var
	 *     Atom returns Var
	 *     Var returns Var
	 *     LiteralOrVar returns Var
	 *     LiteralNumOrVar returns Var
	 *
	 * Constraint:
	 *     declaration=[VarDeclaration|ID]
	 */
	protected void sequence_Var(ISerializationContext context, Var semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VAR__DECLARATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VAR__DECLARATION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVarAccess().getDeclarationVarDeclarationIDTerminalRuleCall_1_0_1(), semanticObject.getDeclaration());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns VectorType
	 *     VarTypeSpecifier returns VectorType
	 *     VectorType returns VectorType
	 *
	 * Constraint:
	 *     {VectorType}
	 */
	protected void sequence_VectorType(ISerializationContext context, VectorType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Expression returns VectorLiteral
	 *     SimpleExpression returns VectorLiteral
	 *     SimpleExpression.OrExpression_1_0 returns VectorLiteral
	 *     AndExpression returns VectorLiteral
	 *     AndExpression.AndExpression_1_0 returns VectorLiteral
	 *     EqualsExpression returns VectorLiteral
	 *     EqualsExpression.EqualsExpression_1_0 returns VectorLiteral
	 *     ComparisonExpression returns VectorLiteral
	 *     ComparisonExpression.ComparisonExpression_1_0 returns VectorLiteral
	 *     AdditiveExpression returns VectorLiteral
	 *     AdditiveExpression.Term_1_0 returns VectorLiteral
	 *     MultiplicativeExpression returns VectorLiteral
	 *     MultiplicativeExpression.Factor_1_0 returns VectorLiteral
	 *     Atom returns VectorLiteral
	 *     LiteralOrVar returns VectorLiteral
	 *     Literal returns VectorLiteral
	 *     Vector returns VectorLiteral
	 *
	 * Constraint:
	 *     (x=LiteralNumOrVar y=LiteralNumOrVar z=LiteralNumOrVar)
	 */
	protected void sequence_Vector(ISerializationContext context, VectorLiteral semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR_LITERAL__X) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR_LITERAL__X));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR_LITERAL__Y) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR_LITERAL__Y));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.VECTOR_LITERAL__Z) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.VECTOR_LITERAL__Z));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getVectorAccess().getXLiteralNumOrVarParserRuleCall_3_0(), semanticObject.getX());
		feeder.accept(grammarAccess.getVectorAccess().getYLiteralNumOrVarParserRuleCall_5_0(), semanticObject.getY());
		feeder.accept(grammarAccess.getVectorAccess().getZLiteralNumOrVarParserRuleCall_7_0(), semanticObject.getZ());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     FunctionTypeSpecifier returns VoidType
	 *     VoidType returns VoidType
	 *
	 * Constraint:
	 *     {VoidType}
	 */
	protected void sequence_VoidType(ISerializationContext context, VoidType semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     VarDeclarationOrStatement returns WhileStatement
	 *     StatementOrBlock returns WhileStatement
	 *     Statement returns WhileStatement
	 *     WhileStatement returns WhileStatement
	 *
	 * Constraint:
	 *     (condition=Expression statement=StatementOrBlock)
	 */
	protected void sequence_WhileStatement(ISerializationContext context, WhileStatement semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.WHILE_STATEMENT__CONDITION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.WHILE_STATEMENT__CONDITION));
			if (transientValues.isValueTransient(semanticObject, XsPackage.Literals.WHILE_STATEMENT__STATEMENT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, XsPackage.Literals.WHILE_STATEMENT__STATEMENT));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWhileStatementAccess().getConditionExpressionParserRuleCall_3_0(), semanticObject.getCondition());
		feeder.accept(grammarAccess.getWhileStatementAccess().getStatementStatementOrBlockParserRuleCall_5_0(), semanticObject.getStatement());
		feeder.finish();
	}
	
	
}
